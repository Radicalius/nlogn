> September 12, 2020
# Rocket Taco: HeyTaco! Inspired Rocket.Chat Bot
[repo](repo://rocket-taco)
---

[HeyTaco!](https://www.heytaco.chat/) is a Slack bot that allows you to celebrate team achievement and collaboration.  The idea revolves around giving team mates virtual \"tacos\" to commend them (for example, for helping someone or accomplishing something).  The bot keeps track of the virtual tacos, so you can see how many you and others have received.  The idea is to essentially game-ify collaboration and teamwork.

[]()

I learned about HeyTaco! while I was working at [Thumbtack](https://www.thumbtack.com/) a couple summers ago.  I was also living in a coop, which was also an environment that demanded a great deal of teamwork.  The coop already had a shout out culture; at meetings the first thing we would do was acknowledge people's cooperative deeds.  I felt like HeyTaco! would be a great fit for my coop.  However, HeyTaco! is not free, and currently does not work with [Rocket.Chat](https://rocket.chat/), a free, self-hosted Slack alternative that my coop was using.  So I set out to make something like HeyTaco! for Rocket.Chat (hence Rocket Taco).

## Rules of Rocket Taco

Mostly adapted from HeyTaco!, with some minor adjustments.

1. Each person gets 5 tacos per day that they can give to others.  (I'm guessing this is to make them feel more valuable, but I don't know for sure...)
2. Each person can distribute their daily allotment of tacos any way they see fit (E.g. they can give all 5 to one person, split them among several people, give less than 5 tacos out, etc)
3. Tacos are distributed by including `:taco:` emojis in a message that mentions the recipient (e.g. `@Alex`).  The number of `:taco:` emojis represents the number of tacos given.  
4. Tacos do not rollover to the next day.  That is, a single person can have at most 5 tacos at any given time.
5. There are ranks that you can get once you've accumulated enough tacos.

## Chat Bot Logic

The chat bot needed to be able to listen for messages with `:taco:` emoji that originated from configured channels and `!` commands sent to it via direct message (e.g. `!leaderboard` to view the leaderboard and `!help` for usage info).  Detecting these relevant messages was done via [webhooks](https://sendgrid.com/blog/whats-webhook/); when the Rocket.Chat server receives a relevant message, it sends an http request to the bot.  The bot can then process the message and respond accordingly using [Rocket.Chat\'s REST API](https://docs.rocket.chat/api/rest-api) (see API Client section for more info\).  In summary, the interactions between the bot and the server look something like this:

1. Bot adds a webhook pointing back to itself using the Rocket.Chat REST API
2. Server gets a message that matches the webhook's criteria
3. Server sends a request to the bot containing the text of the message and other relevant information
4. Bot processes the message
5. Bot reacts to the message (e.g. by sending a response) using the Rocket.Chat REST API

For `!` commands, the bot uses a webhook that catches all direct messages directed to the bot's `/command` endpoint.  For `!help` it simply messages back with a hard-coded string, and for `!leaderboard` and `!tacos` it generates a message using the database contents.

[]()

The bot has a separate webhook that directs `:taco:` messages to the bot's `/taco` endpoint.  The bot then updates its database and sends a direct message to the user indicating that the taco was transferred successfully.  It also direct messages the recipient letting them know that they received a taco and / or leveled up.

[]()

Here's a sample direct message history with rocket-taco to illustrate:

![rocket_taco_dm](/img/rocket_taco_dm.png)

## Web-Facing User Interfaces

Since the bot was already a webserver, I thought it would be helpful for it to display two web pages: one for the full leaderboard and one for configuring and setup of the server.  Both pages are basically pure html `.erb` templates (which are analogous to Jinja templates in python).  I added [Bootstrap](https://getbootstrap.com/) stylesheets to make the pages look presentable.

### Configuration + Setup User Interface

![control_panel](/img/rocket_taco_control_panel.png)

The page is nested inside one big, old-fashioned `form` element with a submit button at the bottom.  When the form is submitted, the new settings are synced with the database.  There are also two status indicators for Rocket.Chat and database connectivity, respectively.  In the upper right hand corner there is the bot's avatar image, which I put there simply to indicate whether it can be retrieved from the server.  

### Leaderboard User Interface

![leaderboard](/img/leaderboard.png)

The leaderboard is displayed as a `table` element that is generated by ruby code in the `.erb` template.  It also contains a simple `form` element which allows the user to change the time and scope of the leaderboard.

## API Client

I implemented a subset of a client for the [Rocket.Chat Rest Api](https://docs.rocket.chat/api/rest-api) in `api.rb`.  I found it helpful to separate out all this API call code from the main logic in `server.rb`.  The endpoints supported are as follows:

* login
* channels.list
* integrations.list
* integrations.create
* integrations.remove
* im.list
* im.members (only for a specific room)
* im.create
* chat.postMessage
* users.setAvatar
* users.list
* channels.list

It uses the [HTTParty](https://github.com/jnunemaker/httparty) library to generate HTTP requests and compile json payloads.

> A note about security: Since the Rocket.Chat REST API sends passwords in plain text, it is not wise to query it over an unencrypted channel.  In my use case, the bot and rocket.chat server are on the same machine, making this a non-issue.  However, if the bot was used with a non-https Rocket.Chat server on a separate computer, an on-path attacker might be able to compromise the bots credentials.    

## Database

By default, rocket-taco uses a [SQLite](https://www.sqlite.org/index.html) database to book keep taco transactions and persist configuration settings.  There was also planned support for [PostgreSQL](https://www.postgresql.org/) database integration.     The schema is defined as follows:

* A settings table containing configuration settings in key-value form.
* A user table which tracks how many tacos each person has left.
* A leaderboard table for each timeframe and scope, which keeps applicable tallies of tacos received and giver per user.
* A transactions table, which tracks each taco given and the reason it was given (i.e. the rest of the message)

The code in `db.rb` provides a higher level interface to the database that is more tenable to the \"business logic\" in the main server code.  A separate script in

## Conclusion

Unfortunately, my coop ultimately decided to use a Facebook group chat as their main communication method.  As a result, this project has been sidelined.  As hardly anyone else uses Rocket.Chat, I doubt much will come out of this project.  However, I had a lot of fun working on it and learned a thing or two about Ruby and Sinatra along the way.  If I did pick this project back up, I would definitely try to make it compatible with a chat service that's more widely used, so that it might be appreciated.  But for now, I think I will retire the project.
